# main.py — MEXC Futures Bot с авто-TP
import os
import json
import asyncio
import logging
import time
import hmac
import hashlib
import sys

import httpx
from fastapi import FastAPI, Request, HTTPException
from telegram import Bot
from slowapi import Limiter
from slowapi.util import get_remote_address

# UTF-8 для логирования
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("mexc-bot")

# === Настройки ===
REQUEST_TIMEOUT = 30
MAX_RETRIES = 3
RETRY_DELAY = 5
RATE_LIMIT = "10/minute"

# === Секреты ===
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "default_token")
TELEGRAM_CHAT_ID = int(os.getenv("TELEGRAM_CHAT_ID", 123456789))
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "default_key")
MEXC_API_SECRET = os.getenv("MEXC_API_SECRET", "default_secret")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "default_webhook_secret")

# === Торговые параметры ===
SYMBOL = "XRP/USDT:USDT"
MEXC_SYMBOL = SYMBOL.replace("/", "_").replace(":USDT", "")
FIXED_AMOUNT_USDT = 5.0
LEVERAGE = 10
TP_PERCENT = 0.5  # % от цены входа

# Инициализация
bot = Bot(token=TELEGRAM_TOKEN)
app = FastAPI()
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

# Глобальные переменные
active_position = False
last_trade_info = None
position_lock = asyncio.Lock()

# ================= Вспомогательные функции =================
async def get_current_price() -> float:
    """Получение текущей цены XRP/USDT"""
    url = f"https://contract.mexc.com/api/v1/contract/ticker?symbol={MEXC_SYMBOL}"
    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        resp = await client.get(url)
        data = resp.json()
        price = float(data['data']['lastPrice'])
        logger.info(f"Цена {MEXC_SYMBOL}: {price}")
        return price

def _sign_mexc_request(body: str):
    """Подпись запроса для MEXC API"""
    timestamp = str(int(time.time() * 1000))
    sign_str = MEXC_API_KEY + timestamp + body
    signature = hmac.new(
        MEXC_API_SECRET.encode('utf-8'),
        sign_str.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    return timestamp, signature

async def submit_order_mexc(order_data: dict):
    """Отправка ордера на MEXC через HTTPS"""
    url = "https://contract.mexc.com/api/v1/private/order/submit"
    body = json.dumps(order_data)
    timestamp, signature = _sign_mexc_request(body)
    headers = {
        "ApiKey": MEXC_API_KEY,
        "Request-Time": timestamp,
        "Signature": signature,
        "Content-Type": "application/json"
    }
    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        for attempt in range(MAX_RETRIES):
            try:
                resp = await client.post(url, headers=headers, content=body)
                data = resp.json()
                if data.get("success"):
                    order_id = data['data']
                    logger.info(f"Ордер отправлен, ID: {order_id}")
                    return data
                else:
                    msg = data.get("message", "Нет сообщения")
                    logger.error(f"MEXC API Error: {msg}")
                    await asyncio.sleep(RETRY_DELAY)
            except Exception as e:
                logger.error(f"Ошибка отправки ордера: {str(e)}")
                await asyncio.sleep(RETRY_DELAY)
    raise Exception("Не удалось отправить ордер")

async def check_balance():
    """Проверка баланса USDT"""
    url = "https://contract.mexc.com/api/v1/private/account/asset/USDT"
    timestamp = str(int(time.time() * 1000))
    body = ""
    sign_str = MEXC_API_KEY + timestamp + body
    signature = hmac.new(
        MEXC_API_SECRET.encode('utf-8'),
        sign_str.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    headers = {"ApiKey": MEXC_API_KEY, "Request-Time": timestamp, "Signature": signature}
    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        resp = await client.get(url, headers=headers)
        data = resp.json()
        free = float(data['data']['available'])
        total = float(data['data']['total'])
        used = total - free
        return {"total": total, "free": free, "used": used}

async def open_position(signal: str):
    """Открытие позиции с автоматическим TP"""
    global active_position, last_trade_info
    async with position_lock:
        if active_position:
            await bot.send_message(TELEGRAM_CHAT_ID, "Позиция уже открыта, сигнал игнорируется")
            return

        balance = await check_balance()
        if balance['free'] < FIXED_AMOUNT_USDT:
            await bot.send_message(TELEGRAM_CHAT_ID, f"Недостаточно USDT: {balance['free']}")
            return

        price = await get_current_price()
        qty = round(FIXED_AMOUNT_USDT * LEVERAGE / price, 4)
        side = 1 if signal.lower() == "buy" else 2  # 1 = buy, 2 = sell

        # Расчет TP
        tp_price = price * (1 + TP_PERCENT/100) if side == 1 else price * (1 - TP_PERCENT/100)

        order_data = {
            "symbol": MEXC_SYMBOL,
            "vol": qty,
            "leverage": LEVERAGE,
            "side": side,
            "type": 5,  # MARKET
            "openType": 1,
            "positionMode": 2,
            "externalOid": f"bot_open_{int(time.time())}",
            "takeProfitPrice": round(tp_price, 6)
        }

        response = await submit_order_mexc(order_data)
        order_id = response['data']
        active_position = True
        last_trade_info = {"signal": signal, "qty": qty, "entry": price, "tp": tp_price, "order_id": order_id}

        msg = f"{signal.upper()} открыта\nЦена: {price}\nКоличество: {qty}\nTP: {tp_price}\nOrder ID: {order_id}"
        await bot.send_message(TELEGRAM_CHAT_ID, msg)
        logger.info(msg)

async def monitor_position():
    """Мониторинг позиции и авто-закрытие при TP"""
    global active_position, last_trade_info
    while True:
        await asyncio.sleep(5)  # проверка каждые 5 секунд
        if active_position:
            url = f"https://contract.mexc.com/api/v1/private/position/list?symbol={MEXC_SYMBOL}"
            timestamp, signature = _sign_mexc_request("")
            headers = {"ApiKey": MEXC_API_KEY, "Request-Time": timestamp, "Signature": signature}
            async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
                resp = await client.get(url, headers=headers)
                data = resp.json()
                positions = data.get("data", [])
                if not positions:
                    active_position = False
                    await bot.send_message(TELEGRAM_CHAT_ID, "Позиция закрыта на TP")
                    last_trade_info = None

# === Webhook для сигналов (TradingView) ===
@app.post("/webhook")
@limiter.limit(RATE_LIMIT)
async def webhook(request: Request):
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401, "Unauthorized")
    data = await request.json()
    signal = data.get("signal")
    if signal not in ["buy", "sell"]:
        raise HTTPException(400, "signal: buy/sell")
    asyncio.create_task(open_position(signal))
    return {"status": "ok"}

# === Запуск FastAPI и мониторинга ===
if __name__ == "__main__":
    import uvicorn
    loop = asyncio.get_event_loop()
    loop.create_task(monitor_position())
    uvicorn.run(app, host="0.0.0.0", port=int(os.getenv("PORT", 8000)))
