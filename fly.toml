import os
import json
import asyncio
import logging
import time
import traceback
from contextlib import asynccontextmanager
import ccxt.async_support as ccxt
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import HTMLResponse
from telegram import Bot
# === –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ===
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("mexc-bot")
# === –ù–ê–°–¢–†–û–ô–ö–ò –¢–ê–ô–ú–ê–£–¢–û–í –ò –ü–û–í–¢–û–†–û–í ===
REQUEST_TIMEOUT = 60
MAX_RETRIES = 3
RETRY_DELAY = 5 # –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –ø–æ–≤—Ç–æ—Ä–∞ —Å 2 –¥–æ 5 —Å–µ–∫—É–Ω–¥
# ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –Ω–µ –∏–∑–º–µ–Ω–µ–Ω)
# === –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ–∫—Ä–µ—Ç–æ–≤ ===
REQUIRED_SECRETS = [
    "TELEGRAM_TOKEN", "TELEGRAM_CHAT_ID", "MEXC_API_KEY",
    "MEXC_API_SECRET", "WEBHOOK_SECRET", "SYMBOL",
    "FIXED_AMOUNT_USDT", "LEVERAGE"
]
for secret in REQUIRED_SECRETS:
    if not os.getenv(secret):
        logger.warning(f"‚ö†Ô∏è –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: {secret} –Ω–µ –∑–∞–¥–∞–Ω –≤ —Å–µ–∫—Ä–µ—Ç–∞—Ö! –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.")
# === –ù–ê–°–¢–†–û–ô–ö–ò –ò–ó –°–ï–ö–†–ï–¢–û–í ===
# –ò—Å–ø–æ–ª—å–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –µ—Å–ª–∏ —Å–µ–∫—Ä–µ—Ç—ã –Ω–µ –∑–∞–¥–∞–Ω—ã
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "default_token")
TELEGRAM_CHAT_ID = int(os.getenv("TELEGRAM_CHAT_ID", 123456789))
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "default_key")
MEXC_API_SECRET = os.getenv("MEXC_API_SECRET", "default_secret")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "default_webhook_secret")
SYMBOL = os.getenv("SYMBOL", "BTC/USDT:USDT")
FIXED_AMOUNT_USDT = float(os.getenv("FIXED_AMOUNT_USDT", 10.0))
LEVERAGE = int(os.getenv("LEVERAGE", 5))
# --- SYMBOL NORMALIZATION (–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï) ---
# MEXC internal symbols often look like 'XRP_USDT', CCXT requires 'XRP/USDT:USDT' for futures.
# This logic attempts to fix non-standard formats provided via environment variables,
# —á—Ç–æ –±—ã–ª–æ –ø—Ä–∏—á–∏–Ω–æ–π –æ—à–∏–±–∫–∏ –≤ –ª–æ–≥–∞—Ö.
original_symbol = SYMBOL
if '_' in SYMBOL and ':' not in SYMBOL and SYMBOL.endswith('USDT'):
    base, quote = SYMBOL.split('_')
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π CCXT —Ñ—å—é—á–µ—Ä—Å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç BASE/QUOTE:QUOTE
    SYMBOL = f"{base}/{quote}:{quote}"
    logger.info(f"üîÑ –°–ò–ú–í–û–õ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ò –ò–°–ü–†–ê–í–õ–ï–ù: {original_symbol} -> {SYMBOL}")
# --- –ö–û–ù–ï–¶ –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–ò ---
logger.info("=== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø MEXC –ë–û–¢–ê ===")
logger.info(f"üìä –ù–∞—Å—Ç—Ä–æ–π–∫–∏: –°–∏–º–≤–æ–ª={SYMBOL}, –°—É–º–º–∞={FIXED_AMOUNT_USDT}, –ü–ª–µ—á–æ={LEVERAGE}")
# === Telegram ===
bot = Bot(token=TELEGRAM_TOKEN)
# === MEXC Exchange ===
exchange = ccxt.mexc({
    'apiKey': MEXC_API_KEY,
    'secret': MEXC_API_SECRET,
    'enableRateLimit': True,
    'options': {
        'defaultType': 'swap',
    },
    'timeout': REQUEST_TIMEOUT * 1000,
    'sandbox': False,
})
# === FastAPI ===
app = FastAPI()
last_trade_info = None
active_position = False
# === –ö–û–ù–°–¢–ê–ù–¢–´ MEXC API ===
# Side types
SIDE_BUY = 1 # Open Long
SIDE_SELL = 2 # Open Short
SIDE_CLOSE_LONG = 3 # Close Long
SIDE_CLOSE_SHORT = 4 # Close Short
# Order types
ORDER_MARKET = 1
ORDER_LIMIT = 2
# Margin types
MARGIN_ISOLATED = 1
MARGIN_CROSS = 2
# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===
@asynccontextmanager
async def error_handler(operation: str):
    try:
        yield
    except Exception as e:
        error_msg = f"‚ùå –û—à–∏–±–∫–∞ –≤ {operation}: {str(e)}\n{traceback.format_exc()}"
        logger.error(error_msg)
        try:
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—à–∏–±–∫–∏ –≤ Telegram
            await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=error_msg[:4000])
        except:
            pass
        # –ù–ï –≤—ã–∑—ã–≤–∞–µ–º raise, —á—Ç–æ–±—ã –Ω–µ –æ–±–æ—Ä–≤–∞—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫—É—é –∑–∞–¥–∞—á—É FastAPI,
        # –∫–æ—Ç–æ—Ä–∞—è –±—ã–ª–∞ –∑–∞–ø—É—â–µ–Ω–∞ —á–µ—Ä–µ–∑ asyncio.create_task.
        # –ï—Å–ª–∏ –Ω—É–∂–Ω–æ, —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ —Å–∞–º–∞ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ.
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å "Task exception was never retrieved" –≤ asyncio.
        # pass
async def get_current_price() -> float:
    async with error_handler("get_current_price"):
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π SYMBOL
        ticker = await exchange.fetch_ticker(SYMBOL)
        price = float(ticker['last'])
        logger.info(f"üí∞ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ {SYMBOL}: {price:.6f}")
        return price
async def check_balance_detailed():
    async with error_handler("check_balance_detailed"):
        balance_data = await exchange.fetch_balance()
       
        total_usdt = balance_data['total'].get('USDT', 0)
        free_usdt = balance_data['free'].get('USDT', 0)
        used_usdt = balance_data['used'].get('USDT', 0)
       
        logger.info(f"üí≥ –ë–∞–ª–∞–Ω—Å USDT - –í—Å–µ–≥–æ: {total_usdt:.4f}, –°–≤–æ–±–æ–¥–Ω–æ: {free_usdt:.4f}, –ó–∞–Ω—è—Ç–æ: {used_usdt:.4f}")
       
        return {
            'total': float(total_usdt),
            'free': float(free_usdt),
            'used': float(used_usdt)
        }
async def set_leverage_fixed():
    """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫—Ä–µ–¥–∏—Ç–Ω–æ–µ –ø–ª–µ—á–æ"""
    async with error_handler("set_leverage"):
        try:
            params = {
                'openType': MARGIN_ISOLATED,
                'positionType': SIDE_BUY,
            }
            await exchange.set_leverage(LEVERAGE, SYMBOL, params)
            logger.info(f"‚ö° –ü–ª–µ—á–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {LEVERAGE}x (isolated)")
        except ccxt.ExchangeError as e:
            # –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –ø–ª–µ—á–æ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ
            if 'Leverage not modified' in str(e) or 'does not allow to change leverage' in str(e):
                 logger.warning(f"‚ö†Ô∏è –ü–ª–µ—á–æ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∏–ª–∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω–æ: {e}")
            else:
                 raise # –ï—Å–ª–∏ –æ—à–∏–±–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è, –≤—ã–∑—ã–≤–∞–µ–º –æ–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ: {e}")
async def calculate_qty() -> float:
    """–†–ê–°–ß–ï–¢: —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—É–º–º–∞ / —Ü–µ–Ω–∞, —Å –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ–º –ø–æ —Ç–æ—á–Ω–æ—Å—Ç–∏ —Ä—ã–Ω–∫–∞"""
    async with error_handler("calculate_qty"):
        price = await get_current_price()
       
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –¥–∞–Ω–Ω—ã–µ —Ä—ã–Ω–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        if SYMBOL not in exchange.markets:
            logger.error("‚ùå –î–∞–Ω–Ω—ã–µ –æ —Ä—ã–Ω–∫–µ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã. –ü–æ–ø—ã—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–µ–π—á–∞—Å.")
            # –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ —Ä—ã–Ω–∫–æ–≤
            try:
                await exchange.load_markets()
            except Exception as e:
                logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä—ã–Ω–∫–æ–≤: {e}")
           
            # –ï—Å–ª–∏ –ø–æ—Å–ª–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–≥—Ä—É–∑–∫–∏ SYMBOL –≤—Å–µ –µ—â–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, —ç—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞.
            if SYMBOL not in exchange.markets:
                 # –¢–µ–ø–µ—Ä—å, –±–ª–∞–≥–æ–¥–∞—Ä—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏, —ç—Ç–∞ –æ—à–∏–±–∫–∞ –¥–æ–ª–∂–Ω–∞ –≤–æ–∑–Ω–∏–∫–∞—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–∏
                 # —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–±–ª–µ–º–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è/–æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Å–∏–º–≤–æ–ª–∞ –Ω–∞ –±–∏—Ä–∂–µ.
                 raise ccxt.ExchangeError(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ —Ç–æ—á–Ω–æ—Å—Ç–∏ –¥–ª—è —Å–∏–º–≤–æ–ª–∞ {SYMBOL} (–ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç)")
       
        market = exchange.markets[SYMBOL]
        precision = market['precision']['amount']
       
        # 2. –†–∞—Å—á–µ—Ç –±–∞–∑–æ–≤–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ (–≤–∫–ª—é—á–∞—è –ø–ª–µ—á–æ)
        quantity = (FIXED_AMOUNT_USDT * LEVERAGE) / price
       
        logger.info(f"üî¢ –†–∞—Å—á–µ—Ç: ({FIXED_AMOUNT_USDT} * {LEVERAGE}) / {price} = {quantity} (–Ω–µ–æ–∫—Ä—É–≥–ª–µ–Ω–Ω–æ–µ)")
       
        # 3. –û–∫—Ä—É–≥–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –∫–æ–Ω—Ç—Ä–∞–∫—Ç–∞
        quantity_precise = exchange.amount_to_precision(SYMBOL, quantity)
        quantity = float(quantity_precise)
       
        # 4. –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ —Å—Ç–æ–∏–º–æ—Å—Ç—å
        MIN_NOTIONAL_USDT = 5.0 # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–æ—Ç–∏–æ–Ω–∞–ª –¥–ª—è MEXC Futures
       
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ª–æ—Ç-—Å–∞–π–∑–∞ (quantity)
        if market['limits']['amount']['min'] and quantity < market['limits']['amount']['min']:
             quantity = market['limits']['amount']['min']
             logger.warning(f"‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ª–æ—Ç-—Å–∞–π–∑–∞: {quantity}")
       
        order_value = quantity * price
       
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –Ω–æ—Ç–∏–æ–Ω–∞–ª–∞ (—Å—Ç–æ–∏–º–æ—Å—Ç–∏ –æ—Ä–¥–µ—Ä–∞)
        if order_value < MIN_NOTIONAL_USDT:
            min_quantity_needed = MIN_NOTIONAL_USDT / price
            min_quantity_precise = exchange.amount_to_precision(SYMBOL, min_quantity_needed)
            min_quantity = float(min_quantity_precise)
           
            # –ë–µ—Ä–µ–º –±–æ–ª—å—à–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            quantity = max(quantity, min_quantity)
           
            logger.warning(f"‚ö†Ô∏è –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã {MIN_NOTIONAL_USDT} USDT: {quantity}")
            # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º order_value –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
            order_value = quantity * price
        logger.info(f"üíµ –°—Ç–æ–∏–º–æ—Å—Ç—å –æ—Ä–¥–µ—Ä–∞ (–ù–æ—Ç–∏–æ–Ω–∞–ª): {order_value:.2f} USDT")
        logger.info(f"üìä –ò—Ç–æ–≥–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {quantity} {SYMBOL} (–¢–æ—á–Ω–æ—Å—Ç—å: {precision})")
        return quantity
async def create_order_mexc_format(symbol: str, side: int, vol: float, price: float = None,
                                 leverage: int = LEVERAGE, openType: int = MARGIN_ISOLATED,
                                 externalOid: str = None):
    """–°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç–µ MEXC API"""
   
    order_params = {
        'symbol': symbol,
        'vol': vol,
        'leverage': leverage,
        'side': side,
        'type': ORDER_MARKET, # –≤—Å–µ–≥–¥–∞ —Ä—ã–Ω–æ—á–Ω—ã–π –æ—Ä–¥–µ—Ä
        'openType': openType,
    }
   
    if externalOid:
        order_params['externalOid'] = externalOid
   
    logger.info(f"üéØ –°–æ–∑–¥–∞–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ MEXC —Ñ–æ—Ä–º–∞—Ç–µ:")
    logger.info(f" –ü–∞—Ä–∞–º–µ—Ç—Ä—ã: {json.dumps(order_params, indent=2)}")
   
    return order_params
async def submit_order_mexc(order_data: dict):
    """–û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä –Ω–∞ MEXC —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
   
    for attempt in range(MAX_RETRIES):
        try:
            logger.info(f"üîÑ –ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_RETRIES} –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ä–¥–µ—Ä–∞")
           
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤—ã–π API –≤—ã–∑–æ–≤ –¥–ª—è MEXC
            response = await exchange.contractPrivatePostOrderSubmit(order_data)
           
            logger.info(f"‚úÖ –û—Ä–¥–µ—Ä –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω —É—Å–ø–µ—à–Ω–æ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}!")
            logger.info(f" –û—Ç–≤–µ—Ç: {response}")
           
            return response
           
        except ccxt.RequestTimeout as e:
            logger.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {str(e)}")
           
            if attempt < MAX_RETRIES - 1:
                logger.info(f"üí§ –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {RETRY_DELAY} —Å–µ–∫...")
                await asyncio.sleep(RETRY_DELAY)
                continue
            else:
                logger.error(f"üî¥ –í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å —Ç–∞–π–º–∞—É—Ç–æ–º")
                raise
               
        except ccxt.NetworkError as e:
            logger.warning(f"üåê –û—à–∏–±–∫–∞ —Å–µ—Ç–∏ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {str(e)}")
           
            if attempt < MAX_RETRIES - 1:
                logger.info(f"üí§ –ü–æ–≤—Ç–æ—Ä —á–µ—Ä–µ–∑ {RETRY_DELAY} —Å–µ–∫...")
                await asyncio.sleep(RETRY_DELAY)
                continue
            else:
                logger.error(f"üî¥ –í—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –∑–∞–≤–µ—Ä—à–∏–ª–∏—Å—å –æ—à–∏–±–∫–æ–π —Å–µ—Ç–∏")
                raise
               
        except Exception as e:
            logger.error(f"üî¥ –û—à–∏–±–∫–∞ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}: {str(e)}")
            raise
    return None
async def open_position_mexc(signal: str):
    global last_trade_info, active_position
   
    async with error_handler("open_position_mexc"):
        logger.info(f"üöÄ –û–¢–ö–†–´–¢–ò–ï –ü–û–ó–ò–¶–ò–ò {signal.upper()} –Ω–∞ {FIXED_AMOUNT_USDT} USDT —Å –ø–ª–µ—á–æ–º {LEVERAGE}x")
       
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ
        try:
            await set_leverage_fixed()
            await asyncio.sleep(1)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –≥–∞—Ä–∞–Ω—Ç–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞: {e}")
       
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å
        balance_data = await check_balance_detailed()
        balance = balance_data['total']
        logger.info(f"üí≥ –ë–∞–ª–∞–Ω—Å: {balance:.2f} USDT, –¢—Ä–µ–±—É–µ—Ç—Å—è: {FIXED_AMOUNT_USDT} USDT")
       
        if balance < FIXED_AMOUNT_USDT:
            raise ValueError(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤. –ù—É–∂–Ω–æ: {FIXED_AMOUNT_USDT} USDT, –µ—Å—Ç—å: {balance:.2f} USDT")
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å —É—á–µ—Ç–æ–º —Ç–æ—á–Ω–æ—Å—Ç–∏
        # –ï—Å–ª–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –æ—à–∏–±–∫–∞, –æ–Ω–∞ –±—É–¥–µ—Ç –ø–µ—Ä–µ—Ö–≤–∞—á–µ–Ω–∞ error_handler
        qty = await calculate_qty()
       
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–æ—Ä–æ–Ω—É –¥–ª—è MEXC API
        if signal.lower() == "buy":
            side = SIDE_BUY
            side_text = "BUY/LONG"
        else:
            side = SIDE_SELL
            side_text = "SELL/SHORT"
       
        logger.info(f"üéØ –§–∏–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ä–¥–µ—Ä–∞: {side_text} {qty} {SYMBOL}")
        # –°–æ–∑–¥–∞–µ–º –æ—Ä–¥–µ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç–µ MEXC
        external_oid = f"bot_{int(time.time())}_{signal}"
        order_data = await create_order_mexc_format(
            symbol=SYMBOL,
            side=side,
            vol=qty,
            leverage=LEVERAGE,
            openType=MARGIN_ISOLATED,
            externalOid=external_oid
        )
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä
        response = await submit_order_mexc(order_data)
       
        if not response:
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫")
        logger.info(f"‚úÖ –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω: {response}")
        # –î–∞–µ–º –±–∏—Ä–∂–µ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ä–¥–µ—Ä
        await asyncio.sleep(2)
        # –ü–æ–ª—É—á–∞–µ–º —Ü–µ–Ω—É –≤—Ö–æ–¥–∞
        entry_price = await get_current_price()
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å–¥–µ–ª–∫–µ
        active_position = True
        last_trade_info = {
            "signal": signal,
            "side": side,
            "side_text": side_text,
            "vol": qty,
            "entry": entry_price,
            "amount_usdt": FIXED_AMOUNT_USDT,
            "leverage": LEVERAGE,
            "balance": balance,
            "order_data": order_data,
            "response": response,
            "externalOid": external_oid,
            "timestamp": time.time()
        }
        position_size = qty * entry_price
       
        msg = (f"‚úÖ {side_text} –û–¢–ö–†–´–¢–ê\n"
               f"–°–∏–º–≤–æ–ª: {SYMBOL}\n"
               f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {qty}\n"
               f"–î–µ–ø–æ–∑–∏—Ç: {FIXED_AMOUNT_USDT} USDT\n"
               f"–ü–ª–µ—á–æ: {LEVERAGE}x\n"
               f"–†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: {position_size:.2f} USDT\n"
               f"–¶–µ–Ω–∞: ${entry_price:.4f}\n"
               f"External OID: {external_oid}")
       
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=msg)
        logger.info("üéâ –ü–û–ó–ò–¶–ò–Ø –£–°–ü–ï–®–ù–û –û–¢–ö–†–´–¢–ê!")
async def close_position_mexc():
    global active_position, last_trade_info
   
    async with error_handler("close_position_mexc"):
        if not active_position:
            logger.info("‚ùå –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è")
            return {"status": "error", "message": "No active position"}
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –ø–æ–∑–∏—Ü–∏—é
        positions = await exchange.fetch_positions([SYMBOL])
        current_pos = None
       
        for pos in positions:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –Ω–∞—à —Å–∏–º–≤–æ–ª –∏ –æ–±—ä–µ–º –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ > 0
            if pos['symbol'] == SYMBOL and float(pos['contracts']) > 0:
                current_pos = pos
                break
       
        if not current_pos:
            logger.warning("‚ö†Ô∏è –ü–æ–∑–∏—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ –±–∏—Ä–∂–µ, —Å–±—Ä–æ—Å —Ñ–ª–∞–≥–∞")
            active_position = False
            return {"status": "error", "message": "Position not found on exchange"}
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–æ—Ä–æ–Ω—É –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è
        if current_pos['side'] == "long":
            close_side = SIDE_CLOSE_LONG
            close_side_text = "CLOSE_LONG"
            # –î–ª—è —Ä–∞—Å—á–µ—Ç–∞ P&L –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
            pnl_direction = 1
        else:
            close_side = SIDE_CLOSE_SHORT
            close_side_text = "CLOSE_SHORT"
            # –î–ª—è —Ä–∞—Å—á–µ—Ç–∞ P&L –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
            pnl_direction = -1
        qty = float(current_pos['contracts'])
       
        logger.info(f"üîí –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏: {close_side_text} {qty} {SYMBOL}")
        # –°–æ–∑–¥–∞–µ–º –æ—Ä–¥–µ—Ä –∑–∞–∫—Ä—ã—Ç–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ MEXC
        external_oid = f"close_{int(time.time())}"
        order_data = await create_order_mexc_format(
            symbol=SYMBOL,
            side=close_side,
            vol=qty,
            leverage=LEVERAGE,
            openType=MARGIN_ISOLATED,
            externalOid=external_oid
        )
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä –∑–∞–∫—Ä—ã—Ç–∏—è
        response = await submit_order_mexc(order_data)
       
        if not response:
            raise Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ä–¥–µ—Ä –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ—Å–ª–µ –≤—Å–µ—Ö –ø–æ–ø—ã—Ç–æ–∫")
        # –î–∞–µ–º –±–∏—Ä–∂–µ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—Ä–¥–µ—Ä
        await asyncio.sleep(2)
       
        exit_price = await get_current_price()
       
        # –†–∞—Å—á–µ—Ç PnL (–∏—Å–ø–æ–ª—å–∑—É–µ–º entryPrice –∏–∑ –±–∏—Ä–∂–∏, –µ—Å–ª–∏ last_trade_info –Ω–µ –∞–∫—Ç—É–∞–ª–µ–Ω)
        entry_price = last_trade_info['entry'] if last_trade_info and 'entry' in last_trade_info else float(current_pos['entryPrice'])
       
        # –†–∞—Å—á–µ—Ç P&L –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö: (–í—ã—Ö–æ–¥ - –í—Ö–æ–¥) / –í—Ö–æ–¥ * 100 * –ü–ª–µ—á–æ * –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        pnl_percent = ((exit_price - entry_price) / entry_price * 100 * LEVERAGE * pnl_direction)
       
        msg = (f"üîí –ü–û–ó–ò–¶–ò–Ø –ó–ê–ö–†–´–¢–ê\n"
               f"–°–∏–º–≤–æ–ª: {SYMBOL}\n"
               f"–¢–∏–ø: {close_side_text}\n"
               f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {qty}\n"
               f"–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: ${entry_price:.4f}\n"
               f"–¶–µ–Ω–∞ –≤—ã—Ö–æ–¥–∞: ${exit_price:.4f}\n"
               f"P&L: {pnl_percent:+.2f}%\n"
               f"External OID: {external_oid}")
       
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=msg)
       
        active_position = False
        last_trade_info = None # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–¥–µ–ª–∫–µ
        logger.info("‚úÖ –ü–û–ó–ò–¶–ò–Ø –£–°–ü–ï–®–ù–û –ó–ê–ö–†–´–¢–ê")
       
        return {
            "status": "ok",
            "message": "Position closed",
            "pnl_percent": pnl_percent,
            "close_order": order_data
        }
# === FastAPI Routes ===
@app.on_event("startup")
async def startup_event():
    async with error_handler("startup"):
        logger.info("üöÄ –ó–ê–ü–£–°–ö –ë–û–¢–ê. –ó–∞–≥—Ä—É–∑–∫–∞ —Ä—ã–Ω–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö...")
       
        # –ö–†–ò–¢–ò–ß–ù–û: –ó–∞–≥—Ä—É–∂–∞–µ–º —Ä—ã–Ω–∫–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è precision
        await exchange.load_markets()
        try:
            await set_leverage_fixed()
        except:
            logger.warning("‚ö†Ô∏è –ü–ª–µ—á–æ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ - –ø—Ä–æ–¥–æ–ª–∂–∏–º –±–µ–∑ –≥–∞—Ä–∞–Ω—Ç–∏–∏.")
       
        balance_data = await check_balance_detailed()
        balance = balance_data['total']
        price = await get_current_price()
       
        msg = (f"‚úÖ MEXC Futures Bot –ó–ê–ü–£–©–ï–ù!\n\n"
               f"üí∞ –ë–∞–ª–∞–Ω—Å: {balance:.2f} USDT\n"
               f"üìä –°–∏–º–≤–æ–ª: {SYMBOL}\n"
               f"üí∞ –¶–µ–Ω–∞: ${price:.4f}\n"
               f"üíµ –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—É–º–º–∞: {FIXED_AMOUNT_USDT} USDT\n"
               f"‚ö° –ü–ª–µ—á–æ: {LEVERAGE}x\n"
               f"üîß –§–æ—Ä–º–∞—Ç: MEXC Native API\n\n"
               f"üí° –ì–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
       
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=msg)
        logger.info("ü§ñ –ë–û–¢ –£–°–ü–ï–®–ù–û –ó–ê–ü–£–©–ï–ù")
@app.on_event("shutdown")
async def shutdown_event():
    logger.info("üõë –û–°–¢–ê–ù–û–í–ö–ê –ë–û–¢–ê")
    try:
        await exchange.close()
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text="üî¥ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ: {e}")
@app.post("/webhook")
async def webhook(request: Request):
    logger.info("üì® –ü–û–õ–£–ß–ï–ù WEBHOOK –ó–ê–ü–†–û–°")
   
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401, detail="Unauthorized")
    try:
        data = await request.json()
        signal = data.get("signal")
       
        logger.info(f"üìä Webhook –¥–∞–Ω–Ω—ã–µ: signal={signal}")
       
        if signal not in ["buy", "sell", "close"]:
            return {"status": "error", "message": "signal must be 'buy', 'sell' or 'close'"}
       
        if signal == "close":
             # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤–µ–±—Ö—É–∫,
             # –∞ –æ—à–∏–±–∫–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ close_position_mexc
             asyncio.create_task(close_position_mexc())
        else:
             # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É, —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –≤–µ–±—Ö—É–∫,
             # –∞ –æ—à–∏–±–∫–∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ open_position_mexc
             asyncio.create_task(open_position_mexc(signal))
       
        return {"status": "ok", "message": f"{signal} signal received"}
       
    except Exception as e:
        logger.error(f"‚ùå Webhook error: {e}")
        return {"status": "error", "message": str(e)}
@app.post("/close")
async def close_position_endpoint(request: Request):
    """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é"""
    logger.info("üîí –ó–ê–ü–†–û–° –ù–ê –ó–ê–ö–†–´–¢–ò–ï –ü–û–ó–ò–¶–ò–ò")
   
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401, detail="Unauthorized")
   
    try:
        result = await close_position_mexc()
        return result
    except Exception as e:
        logger.error(f"‚ùå Close position error: {e}")
        return {"status": "error", "message": str(e)}
@app.post("/order/mexc")
async def create_order_mexc_endpoint(request: Request):
    """–°–æ–∑–¥–∞—Ç—å –æ—Ä–¥–µ—Ä –≤ —Ñ–æ—Ä–º–∞—Ç–µ MEXC API"""
    logger.info("üéØ –°–û–ó–î–ê–ù–ò–ï –û–†–î–ï–†–ê MEXC –§–û–†–ú–ê–¢")
   
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401, detail="Unauthorized")
   
    try:
        data = await request.json()
       
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        required_fields = ['symbol', 'side', 'vol']
        for field in required_fields:
            if field not in data:
                return {"status": "error", "message": f"Missing required field: {field}"}
       
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        order_data = {
            'symbol': data['symbol'],
            'side': data['side'],
            'vol': float(data['vol']), # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º vol –≤ float
            'leverage': data.get('leverage', LEVERAGE),
            'type': data.get('type', ORDER_MARKET),
            'openType': data.get('openType', MARGIN_ISOLATED),
        }
       
        if 'externalOid' in data:
            order_data['externalOid'] = data['externalOid']
       
        logger.info(f"üì¶ –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ –æ—Ä–¥–µ—Ä–∞: {json.dumps(order_data, indent=2)}")
       
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ä–¥–µ—Ä
        response = await submit_order_mexc(order_data)
       
        if response:
            return {
                "status": "ok",
                "message": "Order created",
                "order_data": order_data,
                "response": response
            }
        else:
            return {"status": "error", "message": "Failed to create order"}
           
    except Exception as e:
        logger.error(f"‚ùå Create order error: {e}")
        return {"status": "error", "message": str(e)}
@app.get("/health")
async def health_check():
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ä—ã–Ω–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        if not exchange.markets or SYMBOL not in exchange.markets:
             await exchange.load_markets()
        price = await get_current_price()
        balance_data = await check_balance_detailed()
        balance = balance_data['total']
       
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
        positions = await exchange.fetch_positions([SYMBOL])
        position_info = None
        for pos in positions:
            if pos['symbol'] == SYMBOL and float(pos['contracts']) > 0:
                position_info = {
                    'side': pos['side'],
                    'contracts': float(pos['contracts']),
                    'entry_price': float(pos['entryPrice']),
                    'unrealized_pnl': float(pos['unrealizedPnl'])
                }
                break
       
        return {
            "status": "healthy",
            "exchange_connected": price > 0,
            "balance_available": balance > FIXED_AMOUNT_USDT,
            "active_position": active_position,
            "position_info": position_info,
            "current_price": price,
            "balance": balance_data,
            "fixed_amount": FIXED_AMOUNT_USDT,
            "leverage": LEVERAGE,
            "symbol": SYMBOL,
            "last_trade": last_trade_info,
            "mexc_constants": {
                "SIDE_BUY": SIDE_BUY,
                "SIDE_SELL": SIDE_SELL,
                "SIDE_CLOSE_LONG": SIDE_CLOSE_LONG,
                "SIDE_CLOSE_SHORT": SIDE_CLOSE_SHORT,
                "ORDER_MARKET": ORDER_MARKET,
                "ORDER_LIMIT": ORDER_LIMIT,
                "MARGIN_ISOLATED": MARGIN_ISOLATED,
                "MARGIN_CROSS": MARGIN_CROSS
            },
            "timestamp": time.time()
        }
    except Exception as e:
        logger.error(f"‚ùå Health check failed: {e}")
        return {"status": "unhealthy", "error": str(e)}
@app.get("/")
async def home():
    global last_trade_info, active_position
   
    try:
        balance_data = await check_balance_detailed()
        balance = balance_data['total']
        price = await get_current_price()
       
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–∑–∏—Ü–∏–∏
        positions = await exchange.fetch_positions([SYMBOL])
        position_details = None
        for pos in positions:
            if pos['symbol'] == SYMBOL and float(pos['contracts']) > 0:
                position_details = {
                    'side': pos['side'],
                    'contracts': float(pos['contracts']),
                    'entry_price': float(pos['entryPrice']),
                    'unrealized_pnl': float(pos['unrealizedPnl'])
                }
                break
       
        status = "–ê–ö–¢–ò–í–ù–ê" if active_position else "–ù–ï–¢"
        status_color = "success" if active_position else "warning"
       
        html_content = f"""
        <html>
            <head>
                <title>MEXC Futures Bot</title>
                <meta charset="utf-8">
                <style>
                    body {{ font-family: Arial, sans-serif; background: #1e1e1e; color: white; padding: 20px; }}
                    .card {{ background: #2d2d2d; padding: 20px; margin: 10px 0; border-radius: 10px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); }}
                    .success {{ color: #00b894; font-weight: bold; }}
                    .warning {{ color: #fdcb6e; font-weight: bold; }}
                    .danger {{ color: #e74c3c; font-weight: bold; }}
                    .info {{ color: #74b9ff; }}
                    button {{ background: #00b894; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; transition: background 0.3s; }}
                    button:hover {{ background: #008f71; }}
                    .danger-btn {{ background: #e74c3c; }}
                    .danger-btn:hover {{ background: #c0392b; }}
                    pre {{ background: #1a1a1a; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; }}
                    a {{ color: #74b9ff; text-decoration: none; }}
                    a:hover {{ text-decoration: underline; }}
                </style>
            </head>
            <body>
                <h1 class="success">ü§ñ MEXC Futures Bot (Native API)</h1>
               
                <div class="card">
                    <h3>üí∞ –ë–ê–õ–ê–ù–°</h3>
                    <p><b>USDT –í—Å–µ–≥–æ:</b> <span class="info">{balance:.2f}</span></p>
                    <p><b>USDT –°–≤–æ–±–æ–¥–Ω–æ:</b> {balance_data['free']:.2f}</p>
                    <p><b>USDT –ó–∞–Ω—è—Ç–æ:</b> {balance_data['used']:.2f}</p>
                </div>
               
                <div class="card">
                    <h3>üìä –°–¢–ê–¢–£–° –†–´–ù–ö–ê</h3>
                    <p><b>–°–∏–º–≤–æ–ª:</b> <span class="info">{SYMBOL}</span></p>
                    <p><b>–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞:</b> <span class="info">${price:.4f}</span></p>
                    <p><b>–ü–æ–∑–∏—Ü–∏—è:</b> <span class="{status_color}">{status}</span></p>
                </div>
        """
       
        if position_details:
            pnl_class = "success" if position_details['unrealized_pnl'] > 0 else "danger"
            html_content += f"""
                <div class="card">
                    <h3>üìà –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –ü–û–ó–ò–¶–ò–ò (–ë–∏—Ä–∂–∞)</h3>
                    <p><b>–°—Ç–æ—Ä–æ–Ω–∞:</b> <span class="{pnl_class}">{position_details['side'].upper()}</span></p>
                    <p><b>–ö–æ–Ω—Ç—Ä–∞–∫—Ç—ã:</b> {position_details['contracts']}</p>
                    <p><b>–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞:</b> ${position_details['entry_price']:.4f}</p>
                    <p><b>–ù–µ–∑–∞–∫—Ä—ã—Ç—ã–π P&L:</b> <span class="{pnl_class}">{position_details['unrealized_pnl']:+.4f} USDT</span></p>
                </div>
            """
       
        html_content += f"""
                <div class="card">
                    <h3>‚ö° –ù–ê–°–¢–†–û–ô–ö–ò –¢–û–†–ì–û–í–õ–ò</h3>
                    <p><b>–§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—É–º–º–∞:</b> <span class="info">{FIXED_AMOUNT_USDT} USDT</span></p>
                    <p><b>–ü–ª–µ—á–æ:</b> <span class="info">{LEVERAGE}x</span></p>
                    <p><b>Webhook Secret:</b> <span class="warning">***{WEBHOOK_SECRET[-4:]}</span></p>
                    <p><b>–§–æ—Ä–º–∞—Ç API:</b> MEXC Native</p>
                </div>
               
                <div class="card">
                    <h3>üîó –ö–û–ù–ï–ß–ù–´–ï –¢–û–ß–ö–ò (Endpoints)</h3>
                    <p><b>POST /webhook</b> (–î–ª—è TradingView —Å–∏–≥–Ω–∞–ª–æ–≤)</p>
                    <p><b>POST /close</b> (–î–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è)</p>
                    <p><b>GET /health</b> (–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞)</p>
                </div>
        """
       
        if last_trade_info:
            html_content += f"""
                <div class="card">
                    <h3>üìà –ü–æ—Å–ª–µ–¥–Ω—è—è —Å–¥–µ–ª–∫–∞ (–õ–æ–∫–∞–ª—å–Ω—ã–π –∫—ç—à)</h3>
                    <pre>{json.dumps(last_trade_info, indent=2, ensure_ascii=False, default=str)}</pre>
                </div>
            """
       
        close_button = ""
        if active_position:
            close_button = '<form action="/close" method="post" style="margin: 10px 0;"><button type="submit" class="danger-btn">üîí –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é</button></form>'
       
        html_content += f"""
                <div class="card">
                    <h3>üîß –î–µ–π—Å—Ç–≤–∏—è</h3>
                    <p><a href="/health" target="_blank">üîç Health Check (JSON)</a></p>
                    {close_button}
                </div>
            </body>
        </html>
        """
       
        return HTMLResponse(html_content)
    except Exception as e:
        return HTMLResponse(f"<html><body><h1>‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏: {str(e)}</h1></body></html>")
if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    # –í production-—Å—Ä–µ–¥–µ uvicorn –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è —á–µ—Ä–µ–∑ ASGI-—Å–µ—Ä–≤–µ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä, Gunicorn),
    # –∑–¥–µ—Å—å –æ—Å—Ç–∞–≤–ª–µ–Ω –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞
    uvicorn.run(app, host="0.0.0.0", port=port)
