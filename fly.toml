# main.py ‚Äî MEXC Futures Bot (Fixed Leverage + Improvements)
import os
import json
import asyncio
import logging
import time
import traceback
from contextlib import asynccontextmanager
import ccxt.async_support as ccxt
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import HTMLResponse
from telegram import Bot
from slowapi import Limiter
from slowapi.util import get_remote_address

# === –ù–ê–°–¢–†–û–ô–ö–ê –õ–û–ì–ò–†–û–í–ê–ù–ò–Ø ===
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("mexc-bot")

# === –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ===
REQUEST_TIMEOUT = 30
MAX_RETRIES = 3
RETRY_DELAY = 5
RATE_LIMIT = "10/minute"

# === –°–ï–ö–†–ï–¢–´ ===
REQUIRED_SECRETS = [
    "TELEGRAM_TOKEN", "TELEGRAM_CHAT_ID", "MEXC_API_KEY",
    "MEXC_API_SECRET", "WEBHOOK_SECRET", "SYMBOL",
    "FIXED_AMOUNT_USDT", "LEVERAGE"
]

for secret in REQUIRED_SECRETS:
    if not os.getenv(secret):
        logger.warning(f"–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ: {secret} –Ω–µ –∑–∞–¥–∞–Ω! –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–µ—Ñ–æ–ª—Ç.")

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "default_token")
TELEGRAM_CHAT_ID = int(os.getenv("TELEGRAM_CHAT_ID", 123456789))
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "default_key")
MEXC_API_SECRET = os.getenv("MEXC_API_SECRET", "default_secret")
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "default_webhook_secret")
SYMBOL = os.getenv("SYMBOL", "BTC/USDT:USDT")  # CCXT format
FIXED_AMOUNT_USDT = float(os.getenv("FIXED_AMOUNT_USDT", 10.0))
LEVERAGE = max(int(os.getenv("LEVERAGE", 5)), 1)
MAX_RISK_USDT = float(os.getenv("MAX_RISK_USDT", FIXED_AMOUNT_USDT * 3))

# --- –ù–û–†–ú–ê–õ–ò–ó–ê–¶–ò–Ø –°–ò–ú–í–û–õ–ê (CCXT ‚Üí MEXC internal) ---
# –î–ª—è API calls: XRP/USDT:USDT ‚Üí XRP_USDT
def normalize_symbol_for_api(ccxt_symbol: str) -> str:
    return ccxt_symbol.replace('/', '_').replace(':USDT', '')

original_symbol = SYMBOL
if '_' in SYMBOL and ':' not in SYMBOL:
    base, quote = SYMBOL.split('_')
    SYMBOL = f"{base}/{quote}:{quote}"
    logger.info(f"–°–ò–ú–í–û–õ –ò–°–ü–†–ê–í–õ–ï–ù: {original_symbol} ‚Üí {SYMBOL}")

MEXC_SYMBOL = normalize_symbol_for_api(SYMBOL)  # –î–ª—è order submit
logger.info(f"=== MEXC BOT | {SYMBOL} (API: {MEXC_SYMBOL}) | {FIXED_AMOUNT_USDT} USDT | {LEVERAGE}x ===")

# === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
bot = Bot(token=TELEGRAM_TOKEN)
exchange = ccxt.mexc({
    'apiKey': MEXC_API_KEY,
    'secret': MEXC_API_SECRET,
    'enableRateLimit': True,
    'options': {'defaultType': 'swap'},
    'timeout': REQUEST_TIMEOUT * 1000,
    'sandbox': os.getenv("SANDBOX", "False").lower() == "true",
})

app = FastAPI()
limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter

# === –ì–õ–û–ë–ê–õ–¨–ù–´–ï ===
last_trade_info = None
active_position = False
position_lock = asyncio.Lock()

# === –ö–û–ù–°–¢–ê–ù–¢–´ MEXC (–∏–∑ docs) ===
SIDE_BUY = 1       # Open Long
SIDE_SELL = 2      # Open Short
SIDE_CLOSE_LONG = 3
SIDE_CLOSE_SHORT = 4
ORDER_MARKET = 5   # Market order
MARGIN_ISOLATED = 1  # Isolated
POSITION_LONG = 1
POSITION_SHORT = 2

# === –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï ===
@asynccontextmanager
async def error_handler(operation: str):
    try:
        yield
    except Exception as e:
        error_msg = f"–û–®–ò–ë–ö–ê –≤ {operation}: {str(e)}\n{traceback.format_exc()}"
        logger.error(error_msg)
        try:
            await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=error_msg[:4000])
        except:
            pass

async def get_current_price() -> float:
    async with error_handler("get_current_price"):
        ticker = await exchange.fetch_ticker(SYMBOL)
        price = float(ticker['last'])
        logger.info(f"–¶–µ–Ω–∞ {SYMBOL}: {price:.6f}")
        return price

async def check_balance_detailed():
    async with error_handler("check_balance"):
        balance = await exchange.fetch_balance()
        total = balance['total'].get('USDT', 0)
        free = balance['free'].get('USDT', 0)
        used = balance['used'].get('USDT', 0)
        logger.info(f"–ë–∞–ª–∞–Ω—Å: –í—Å–µ–≥–æ {total:.4f}, –°–≤–æ–±–æ–¥–Ω–æ {free:.4f}, –ó–∞–Ω—è—Ç–æ {used:.4f}")
        return {'total': float(total), 'free': float(free), 'used': float(used)}

async def set_leverage_fixed():
    """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ –¥–ª—è LONG –∏ SHORT (isolated)"""
    async with error_handler("set_leverage"):
        params_template = {'openType': MARGIN_ISOLATED}
        try:
            # –î–ª—è LONG
            params_long = params_template.copy()
            params_long['positionType'] = POSITION_LONG
            await exchange.set_leverage(LEVERAGE, SYMBOL, params=params_long)
            logger.info(f"–ü–ª–µ—á–æ {LEVERAGE}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è LONG")

            # –î–ª—è SHORT
            params_short = params_template.copy()
            params_short['positionType'] = POSITION_SHORT
            await exchange.set_leverage(LEVERAGE, SYMBOL, params=params_short)
            logger.info(f"–ü–ª–µ—á–æ {LEVERAGE}x —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –¥–ª—è SHORT")
        except ccxt.ExchangeError as e:
            if 'not modified' in str(e).lower() or 'already set' in str(e).lower():
                logger.info("–ü–ª–µ—á–æ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º)")
            else:
                logger.warning(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞: {e} ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–µ—Ñ–æ–ª—Ç")
                # –ù–µ raise ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º

async def calculate_qty() -> float:
    async with error_handler("calculate_qty"):
        price = await get_current_price()
        if SYMBOL not in exchange.markets:
            logger.warning("–†—ã–Ω–∫–∏ —É—Å—Ç–∞—Ä–µ–ª–∏ ‚Üí –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞")
            await exchange.load_markets(reload=True)
            if SYMBOL not in exchange.markets:
                raise ccxt.ExchangeError(f"–°–∏–º–≤–æ–ª {SYMBOL} –Ω–µ –Ω–∞–π–¥–µ–Ω")

        market = exchange.markets[SYMBOL]
        precision = market['precision']['amount']
        quantity = (FIXED_AMOUNT_USDT * LEVERAGE) / price
        quantity = float(exchange.amount_to_precision(SYMBOL, quantity))

        min_amount = market['limits']['amount']['min'] or 0
        if min_amount and quantity < min_amount:
            quantity = min_amount
            logger.warning(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–≤–µ–ª–∏—á–µ–Ω–æ –¥–æ min: {quantity}")

        order_value = quantity * price
        MIN_NOTIONAL = 5.0  # MEXC min
        if order_value < MIN_NOTIONAL:
            quantity = (MIN_NOTIONAL / price)
            quantity = float(exchange.amount_to_precision(SYMBOL, quantity))
            order_value = quantity * price
            logger.warning(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è min notional {MIN_NOTIONAL} USDT")

        if order_value > MAX_RISK_USDT:
            raise ValueError(f"–†–∏—Å–∫ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç: {order_value:.2f} > {MAX_RISK_USDT}")

        logger.info(f"–†–∞—Å—á—ë—Ç: {quantity} @ {price} = {order_value:.2f} USDT (precision: {precision})")
        return quantity

async def create_order_mexc_format(side: int, vol: float, externalOid: str, tp=None, sl=None, is_close=False):
    """–§–æ—Ä–º–∞—Ç –¥–ª—è MEXC API (docs: type=5 market, symbol=XRP_USDT)"""
    order = {
        'symbol': MEXC_SYMBOL,  # Internal format
        'vol': vol,
        'leverage': LEVERAGE,
        'side': side,
        'type': ORDER_MARKET,  # 5 = market
        'openType': MARGIN_ISOLATED,
        'positionMode': 2,  # One-way
        'externalOid': externalOid,
    }
    if is_close:
        order['reduceOnly'] = True
    if tp:
        order['takeProfitPrice'] = round(tp, 6)
    if sl:
        order['stopLossPrice'] = round(sl, 6)
    logger.info(f"–û—Ä–¥–µ—Ä MEXC: {json.dumps(order, indent=2)}")
    return order

async def submit_order_mexc(order_data: dict):
    """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å —Ç–∞–π–º–∞—É—Ç–æ–º –∏ —Ä–µ—Ç—Ä–∞—è–º–∏"""
    for attempt in range(MAX_RETRIES):
        try:
            logger.info(f"–ü–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{MAX_RETRIES}")
            response = await asyncio.wait_for(
                exchange.contractPrivatePostOrderSubmit(order_data),
                timeout=REQUEST_TIMEOUT
            )
            order_id = response.get('data', 'unknown')
            logger.info(f"–£–°–ü–ï–•! Order ID: {order_id}")
            return response
        except asyncio.TimeoutError:
            logger.warning(f"–¢–ê–ô–ú–ê–£–¢ –Ω–∞ –ø–æ–ø—ã—Ç–∫–µ {attempt + 1}")
        except ccxt.NetworkError as e:
            logger.warning(f"–°–µ—Ç—å: {e}")
        except ccxt.ExchangeError as e:
            if '510' in str(e):  # Rate limit
                logger.warning("Rate limit ‚Äî backoff 10s")
                await asyncio.sleep(10)
            else:
                logger.error(f"API Error: {e}")
                raise
        except Exception as e:
            logger.error(f"–ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
            raise

        if attempt < MAX_RETRIES - 1:
            await asyncio.sleep(RETRY_DELAY)

    raise Exception("–û—Ä–¥–µ—Ä –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –ø–æ—Å–ª–µ —Ä–µ—Ç—Ä–∞–µ–≤")

# === –¢–û–†–ì–û–í–õ–Ø ===
async def open_position_mexc(signal: str, tp_percent: float = None, sl_percent: float = None):
    global last_trade_info, active_position
    async with position_lock:
        if active_position:
            logger.warning("–î—É–±–ª—å: –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –æ—Ç–∫—Ä—ã—Ç–∞!")
            await bot.send_message(TELEGRAM_CHAT_ID, "‚ö†Ô∏è –î–£–ë–õ–¨ –°–ò–ì–ù–ê–õ–ê ‚Äî –ø–æ–∑–∏—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞")
            return

        async with error_handler("open_position"):
            await set_leverage_fixed()
            await asyncio.sleep(1)  # –î–∞—ë–º API –≤—Ä–µ–º—è

            balance_data = await check_balance_detailed()
            if balance_data['free'] < FIXED_AMOUNT_USDT:
                raise ValueError(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å—Ä–µ–¥—Å—Ç–≤: {balance_data['free']:.2f} < {FIXED_AMOUNT_USDT}")

            qty = await calculate_qty()
            side = SIDE_BUY if signal.lower() == "buy" else SIDE_SELL
            side_text = "LONG" if side == SIDE_BUY else "SHORT"

            entry_price = await get_current_price()
            tp_price = entry_price * (1 + tp_percent / 100) if tp_percent else None
            sl_price = entry_price * (1 - sl_percent / 100) if sl_percent else None

            external_oid = f"bot_open_{int(time.time())}_{signal}"
            order_data = await create_order_mexc_format(side, qty, external_oid, tp_price, sl_price)
            response = await submit_order_mexc(order_data)
            order_id = response.get('data', 'unknown')

            active_position = True
            last_trade_info = {
                "signal": signal, "side": side_text, "qty": qty, "entry": entry_price,
                "tp": tp_price, "sl": sl_price, "order_id": order_id, "timestamp": time.time()
            }

            position_size = qty * entry_price
            msg = (f"‚úÖ {side_text} –û–¢–ö–†–´–¢–ê\n"
                   f"–°–∏–º–≤–æ–ª: {SYMBOL}\n"
                   f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {qty}\n"
                   f"–†–∞–∑–º–µ—Ä: {position_size:.2f} USDT\n"
                   f"–ü–ª–µ—á–æ: {LEVERAGE}x\n"
                   f"–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: ${entry_price:.4f}\n"
                   f"{'TP: ${tp_price:.4f}' if tp_price else ''}\n"
                   f"{'SL: ${sl_price:.4f}' if sl_price else ''}\n"
                   f"Order ID: {order_id}")
            await bot.send_message(TELEGRAM_CHAT_ID, text=msg)
            logger.info(f"–ü–û–ó–ò–¶–ò–Ø –û–¢–ö–†–´–¢–ê: {side_text} {qty} @ {entry_price}")

async def close_position_mexc():
    global active_position, last_trade_info
    async with position_lock:
        if not active_position:
            return {"status": "error", "message": "–ù–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏"}

        async with error_handler("close_position"):
            positions = await exchange.fetch_positions([SYMBOL])
            pos = next((p for p in positions if p['symbol'] == SYMBOL and float(p['contracts']) > 0), None)
            if not pos:
                logger.warning("–ü–æ–∑–∏—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ –±–∏—Ä–∂–µ ‚Äî —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥")
                active_position = False
                return {"status": "error", "message": "–ü–æ–∑–∏—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"}

            side = SIDE_CLOSE_LONG if pos['side'] == 'long' else SIDE_CLOSE_SHORT
            qty = float(pos['contracts'])
            entry_price = float(pos['entryPrice'])
            exit_price = await get_current_price()
            realized_pnl = float(pos.get('realizedPnl', 0))
            unrealized_pnl = float(pos.get('unrealizedPnl', 0))

            # PnL % (–ø—Ä–∏–º–µ—Ä–Ω—ã–π)
            pnl_percent = ((exit_price - entry_price) / entry_price * 100 * LEVERAGE) * (1 if pos['side'] == 'long' else -1)

            external_oid = f"bot_close_{int(time.time())}"
            order_data = await create_order_mexc_format(side, qty, external_oid, is_close=True)
            response = await submit_order_mexc(order_data)
            close_order_id = response.get('data', 'unknown')

            msg = (f"üîí –ü–û–ó–ò–¶–ò–Ø –ó–ê–ö–†–´–¢–ê ({pos['side'].upper()})\n"
                   f"–°–∏–º–≤–æ–ª: {SYMBOL}\n"
                   f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {qty}\n"
                   f"–í—Ö–æ–¥: ${entry_price:.4f} ‚Üí –í—ã—Ö–æ–¥: ${exit_price:.4f}\n"
                   f"P&L: {pnl_percent:+.2f}% | {realized_pnl:+.4f} USDT (realized)\n"
                   f"{'+' if unrealized_pnl > 0 else ''}{unrealized_pnl:.4f} USDT (unrealized)\n"
                   f"Close Order ID: {close_order_id}")
            await bot.send_message(TELEGRAM_CHAT_ID, text=msg)

            active_position = False
            last_trade_info = None
            logger.info(f"–ü–û–ó–ò–¶–ò–Ø –ó–ê–ö–†–´–¢–ê: PnL {pnl_percent:+.2f}%")
            return {"status": "ok", "pnl_percent": pnl_percent, "pnl_usdt": realized_pnl}

# === FASTAPI ROUTES ===
@app.on_event("startup")
async def startup():
    async with error_handler("startup"):
        await exchange.load_markets(reload=True)
        await set_leverage_fixed()  # –¢–µ–ø–µ—Ä—å —Å positionType ‚Äî –Ω–µ —É–ø–∞–¥—ë—Ç
        price = await get_current_price()
        balance = (await check_balance_detailed())['total']
        msg = (f"üöÄ MEXC BOT –ó–ê–ü–£–©–ï–ù\n"
               f"–ë–∞–ª–∞–Ω—Å: {balance:.2f} USDT\n"
               f"–°–∏–º–≤–æ–ª: {SYMBOL} (API: {MEXC_SYMBOL})\n"
               f"–°—É–º–º–∞: {FIXED_AMOUNT_USDT} USDT\n"
               f"–ü–ª–µ—á–æ: {LEVERAGE}x\n"
               f"{'SANDBOX MODE' if exchange.sandbox else 'LIVE'}\n"
               f"–ì–æ—Ç–æ–≤ –∫ webhook!")
        await bot.send_message(TELEGRAM_CHAT_ID, text=msg)
        logger.info("ü§ñ –ë–û–¢ –ì–û–¢–û–í")

@app.on_event("shutdown")
async def shutdown():
    logger.info("üõë Shutdown")
    await exchange.close()
    try:
        await bot.send_message(TELEGRAM_CHAT_ID, text="üî¥ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except:
        pass

@app.post("/webhook")
@limiter.limit(RATE_LIMIT)
async def webhook(request: Request):
    logger.info("üì® Webhook –ø–æ–ª—É—á–µ–Ω")
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401, "Unauthorized")
    
    try:
        data = await request.json()
        signal = data.get("signal")
        if signal not in ["buy", "sell", "close"]:
            raise HTTPException(400, "signal must be 'buy', 'sell' or 'close'")
        
        if signal == "close":
            asyncio.create_task(close_position_mexc())
        else:
            tp = data.get("tp_percent")  # e.g., 5.0 for +5%
            sl = data.get("sl_percent")  # e.g., 3.0 for -3%
            asyncio.create_task(open_position_mexc(signal, tp, sl))
        
        return {"status": "ok", "signal": signal}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Webhook error: {e}")
        raise HTTPException(500, str(e))

@app.post("/close")
async def force_close(request: Request):
    if WEBHOOK_SECRET and request.headers.get("Authorization") != f"Bearer {WEBHOOK_SECRET}":
        raise HTTPException(401)
    logger.info("üîí Force close")
    return await close_position_mexc()

@app.get("/health")
async def health():
    try:
        if not exchange.markets:
            await exchange.load_markets()
        price = await get_current_price()
        balance_data = await check_balance_detailed()
        positions = await exchange.fetch_positions([SYMBOL])
        pos_info = next(({
            'side': p['side'],
            'contracts': float(p['contracts']),
            'entry': float(p['entryPrice']),
            'unrealized_pnl': float(p['unrealizedPnl'])
        } for p in positions if p['symbol'] == SYMBOL and float(p['contracts']) > 0), None)
        
        return {
            "status": "healthy",
            "connected": True,
            "active_position": active_position,
            "position_info": pos_info,
            "price": price,
            "balance": balance_data,
            "leverage": LEVERAGE,
            "symbol": SYMBOL,
            "last_trade": last_trade_info,
            "timestamp": time.time()
        }
    except Exception as e:
        logger.error(f"Health error: {e}")
        return {"status": "unhealthy", "error": str(e)}

@app.get("/")
async def dashboard():
    try:
        balance_data = await check_balance_detailed()
        price = await get_current_price()
        positions = await exchange.fetch_positions([SYMBOL])
        pos_details = next(({
            'side': p['side'],
            'contracts': float(p['contracts']),
            'entry': float(p['entryPrice']),
            'unrealized_pnl': float(p['unrealizedPnl'])
        } for p in positions if p['symbol'] == SYMBOL and float(p['contracts']) > 0), None)
        
        status = "–ê–ö–¢–ò–í–ù–ê" if active_position else "–ù–ï–¢"
        status_color = "success" if active_position else "warning"
        
        html = f"""
        <html>
        <head><title>MEXC Bot Dashboard</title>
        <style>body {{font-family:Arial;background:#1e1e1e;color:white;padding:20px;}}
        .card {{background:#2d2d2d;padding:20px;margin:10px 0;border-radius:10px;}}
        .success {{color:#00b894;}} .warning {{color:#fdcb6e;}} .info {{color:#74b9ff;}}
        button {{background:#00b894;color:white;border:none;padding:10px 20px;border-radius:5px;cursor:pointer;}}
        .danger-btn {{background:#e74c3c;}} pre {{background:#1a1a1a;padding:15px;border-radius:5px;}}
        </style></head>
        <body>
        <h1>ü§ñ MEXC Futures Bot</h1>
        
        <div class="card"><h3>üí∞ –ë–ê–õ–ê–ù–°</h3>
        <p>–í—Å–µ–≥–æ: <span class="info">{balance_data['total']:.2f}</span> USDT</p>
        <p>–°–≤–æ–±–æ–¥–Ω–æ: {balance_data['free']:.2f} USDT</p>
        <p>–ó–∞–Ω—è—Ç–æ: {balance_data['used']:.2f} USDT</p></div>
        
        <div class="card"><h3>üìä –†–´–ù–û–ö</h3>
        <p>–°–∏–º–≤–æ–ª: <span class="info">{SYMBOL}</span></p>
        <p>–¶–µ–Ω–∞: <span class="info">${price:.4f}</span></p>
        <p>–ü–æ–∑–∏—Ü–∏—è: <span class="{status_color}">{status}</span></p></div>
        """
        
        if pos_details:
            pnl_class = "success" if pos_details['unrealized_pnl'] > 0 else "danger"
            html += f"""
            <div class="card"><h3>üìà –ü–û–ó–ò–¶–ò–Ø</h3>
            <p>–°—Ç–æ—Ä–æ–Ω–∞: <span class="{pnl_class}">{pos_details['side'].upper()}</span></p>
            <p>–ö–æ–Ω—Ç—Ä–∞–∫—Ç—ã: {pos_details['contracts']}</p>
            <p>–í—Ö–æ–¥: ${pos_details['entry']:.4f}</p>
            <p>PnL: <span class="{pnl_class}">{pos_details['unrealized_pnl']:+.4f} USDT</span></p></div>
            """
        
        html += f"""
        <div class="card"><h3>‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</h3>
        <p>–°—É–º–º–∞: <span class="info">{FIXED_AMOUNT_USDT}</span> USDT</p>
        <p>–ü–ª–µ—á–æ: <span class="info">{LEVERAGE}x</span></p>
        <p>–†–∏—Å–∫ –ª–∏–º–∏—Ç: {MAX_RISK_USDT} USDT</p></div>
        
        <div class="card"><h3>üîó ENDPOINTS</h3>
        <p>POST /webhook (signal: buy/sell/close, optional tp_percent/sl_percent)</p>
        <p>POST /close</p>
        <a href="/health">GET /health (JSON)</a></div>
        """
        
        if last_trade_info:
            html += f'<div class="card"><h3>–ü–æ—Å–ª–µ–¥–Ω—è—è —Å–¥–µ–ª–∫–∞</h3><pre>{json.dumps(last_trade_info, indent=2, default=str)}</pre></div>'
        
        if active_position:
            html += '<div class="card"><form action="/close" method="post"><button class="danger-btn">üîí –ó–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é</button></form></div>'
        
        html += '</body></html>'
        return HTMLResponse(html)
    except Exception as e:
        return HTMLResponse(f"<h1>‚ùå –û—à–∏–±–∫–∞: {str(e)}</h1>")

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
