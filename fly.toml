#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
main.py ‚Äî MEXC Futures opener (TradingView webhook -> MEXC Contract API v1)
–†—É—Å—Å–∫–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏, TP –≤ –æ—Ä–¥–µ—Ä–µ, SL –æ—Ç–∫–ª—é—á—ë–Ω.
–§–∏–∫—Å: 5 USDT, LEVERAGE 10x, SYMBOL XRP_USDT
"""

import os
import time
import json
import hmac
import hashlib
import logging
import asyncio
import traceback
from typing import Optional

import httpx
import ccxt.async_support as ccxt
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from telegram import Bot

# -------------------------
# –ù–ê–°–¢–†–û–ô–ö–ò –ò –ü–ï–†–ï–ú–ï–ù–ù–´–ï
# -------------------------
# –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å —á–µ—Ä–µ–∑ environment –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (—Å–º. —Å–ø–∏—Å–æ–∫ –Ω–∏–∂–µ)
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "")
MEXC_API_SECRET = os.getenv("MEXC_API_SECRET", "")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
TELEGRAM_CHAT_ID = int(os.getenv("TELEGRAM_CHAT_ID", "0") or 0)
WEBHOOK_SECRET = os.getenv("WEBHOOK_SECRET", "supersecret")

# –¢–æ—Ä–≥–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (–ø–æ —Å—É—Ç–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ, –º–æ–∂–Ω–æ –∏–∑–º–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ env)
FIXED_AMOUNT_USDT = float(os.getenv("FIXED_AMOUNT_USDT", "5.0"))   # —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—É–º–º–∞ –≤ USDT
LEVERAGE = int(os.getenv("LEVERAGE", "10"))                       # –ø–ª–µ—á–æ
# ccxt —Å–∏–º–≤–æ–ª –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã (—Ñ–æ—Ä–º–∞—Ç ccxt)
SYMBOL_CCXT = os.getenv("SYMBOL", "XRP/USDT:USDT")                # –¥–ª—è fetch_ticker
# MEXC –∫–æ–Ω—Ç—Ä–∞–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞ (—Ñ–æ—Ä–º–∞—Ç API MEXC: XRP_USDT)
MEXC_SYMBOL = os.getenv("MEXC_SYMBOL", "XRP_USDT")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ HTTP
REQUEST_TIMEOUT = int(os.getenv("REQUEST_TIMEOUT", "20"))
MAX_RETRIES = int(os.getenv("MAX_RETRIES", "3"))
RETRY_DELAY = int(os.getenv("RETRY_DELAY", "2"))

# -------------------------
# –õ–û–ì–ò–†–û–í–ê–ù–ò–ï
# -------------------------
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("mexc-bot")

# -------------------------
# TELEGRAM BOT (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞)
# –∏—Å–ø–æ–ª—å–∑—É–µ–º run_in_executor —á—Ç–æ–±—ã –Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å event loop
# -------------------------
bot = Bot(token=TELEGRAM_TOKEN)

# -------------------------
# CCXT (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ) ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã –∏ precision
# -------------------------
exchange = ccxt.mexc({
    "apiKey": MEXC_API_KEY,
    "secret": MEXC_API_SECRET,
    "enableRateLimit": True,
    "options": {"defaultType": "swap"},  # –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ —Ñ—å—é—á–µ—Ä—Å—ã
    "timeout": REQUEST_TIMEOUT * 1000,
})

# -------------------------
# FastAPI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
# -------------------------
app = FastAPI()

# -------------------------
# –°–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞ –≤ –ø–∞–º—è—Ç–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞
# active_position ‚Äî –∑–∞–ø—Ä–µ—â–∞–µ—Ç –æ—Ç–∫—Ä—ã–≤–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –ø–æ–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∞—è –∞–∫—Ç–∏–≤–Ω–∞
# last_trade ‚Äî –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–¥–µ–ª–∫–µ
# position_lock ‚Äî –∑–∞—â–∏—â–∞–µ—Ç –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –ø—Ä–∏ –≤–µ–±—Ö—É–∫–∞—Ö
# -------------------------
position_lock = asyncio.Lock()
active_position = False
last_trade = None

# -------------------------
# –§—É–Ω–∫—Ü–∏—è –ø–æ–¥–ø–∏—Å–∏ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π MEXC
# signature = HMAC_SHA256(MEXC_API_SECRET, MEXC_API_KEY + timestamp + body_string)
# -------------------------
def _mexc_sign(body_str: str) -> (str, str):
    timestamp = str(int(time.time() * 1000))
    msg = MEXC_API_KEY + timestamp + body_str
    signature = hmac.new(MEXC_API_SECRET.encode('utf-8'), msg.encode('utf-8'), hashlib.sha256).hexdigest()
    return timestamp, signature

# -------------------------
# –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π POST –Ω–∞ MEXC Contract API v1
# –î–µ–ª–∞–µ—Ç retries –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–π JSON
# -------------------------
async def mexc_post(path: str, body: dict) -> dict:
    """
    –û—Ç–ø—Ä–∞–≤–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ POST –∑–∞–ø—Ä–æ—Å–∞ –∫ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–Ω–æ–º—É API MEXC.
    body ‚Äî —Å–ª–æ–≤–∞—Ä—å, –∫–æ—Ç–æ—Ä—ã–π –±—É–¥–µ—Ç —Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞–Ω –≤ JSON –±–µ–∑ –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤.
    """
    url = "https://contract.mexc.com" + path
    # —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–µ–∑ –ª–∏—à–Ω–∏—Ö –ø—Ä–æ–±–µ–ª–æ–≤ (–∫–∞–∫ —Ç—Ä–µ–±—É–µ—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è)
    body_str = json.dumps(body, separators=(",", ":"), ensure_ascii=False)
    timestamp, signature = _mexc_sign(body_str)
    headers = {
        "Content-Type": "application/json",
        "ApiKey": MEXC_API_KEY,
        "Request-Time": timestamp,
        "Signature": signature
    }

    last_exc = None
    async with httpx.AsyncClient(timeout=REQUEST_TIMEOUT) as client:
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                logger.info(f"MEXC POST –ø–æ–ø—ã—Ç–∫–∞ {attempt} -> {path}")
                resp = await client.post(url, headers=headers, content=body_str)
                text = resp.text
                try:
                    data = resp.json()
                except Exception:
                    logger.error(f"–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π JSON –æ—Ç MEXC: {text}")
                    raise Exception(f"Invalid JSON: {text}")

                logger.info(f"–û—Ç–≤–µ—Ç MEXC: {data}")
                return data
            except httpx.TimeoutException as te:
                last_exc = te
                logger.warning(f"–¢–∞–π–º–∞—É—Ç –ø–æ–ø—ã—Ç–∫–∏ {attempt}: {te}")
            except Exception as e:
                last_exc = e
                logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ø—ã—Ç–∫–∏ {attempt}: {e}")
            if attempt < MAX_RETRIES:
                await asyncio.sleep(RETRY_DELAY)
    # –µ—Å–ª–∏ –≤—Å–µ –ø–æ–ø—ã—Ç–∫–∏ –ø—Ä–æ–≤–∞–ª–∏–ª–∏—Å—å ‚Äî –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
    raise last_exc or Exception("MEXC request failed")

# -------------------------
# –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä—ã–Ω–æ—á–Ω–æ–π —Ü–µ–Ω—ã —á–µ—Ä–µ–∑ ccxt (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
# -------------------------
async def fetch_price() -> float:
    """
    –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ü–µ–Ω—É —á–µ—Ä–µ–∑ ccxt ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ –æ–±—ä—ë–º–∞ –∏ TP.
    """
    try:
        ticker = await exchange.fetch_ticker(SYMBOL_CCXT)
        price = float(ticker.get("last") or ticker.get("close") or 0.0)
        logger.info(f"–¶–µ–Ω–∞ {SYMBOL_CCXT}: {price}")
        return price
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ fetch_price: {e}")
        raise

# -------------------------
# –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ–±—ä–µ–º vol (–∫–æ–ª-–≤–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤) –ø–æ —Ñ–æ—Ä–º—É–ª–µ:
# vol = (FIXED_AMOUNT_USDT * LEVERAGE) / price
# –∑–∞—Ç–µ–º –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —Ç–æ—á–Ω–æ—Å—Ç–∏ –±–∏—Ä–∂–∏ —á–µ—Ä–µ–∑ ccxt.amount_to_precision
# -------------------------
async def calculate_vol(amount_usdt: float, price: float) -> float:
    raw_qty = (amount_usdt * LEVERAGE) / price
    try:
        # —É–±–µ–¥–∏–º—Å—è —á—Ç–æ —Ä—ã–Ω–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã
        await exchange.load_markets()
        market = exchange.markets.get(SYMBOL_CCXT)
        if not market:
            raise Exception(f"Market {SYMBOL_CCXT} –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ ccxt")
        # –ø—Ä–∏–≤–µ—Å—Ç–∏ –≤ —Ç–æ—á–Ω–æ—Å—Ç—å –±–∏—Ä–∂–∏
        qty = float(exchange.amount_to_precision(SYMBOL_CCXT, raw_qty))
        if qty <= 0:
            raise Exception("–†–∞—Å—Å—á–∏—Ç–∞–Ω–Ω–æ–µ qty <= 0")
        logger.info(f"–†–∞—Å—Å—á–∏—Ç–∞–Ω vol: raw {raw_qty} -> adjusted {qty}")
        return qty
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ calculate_vol: {e}")
        raise

# -------------------------
# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ (—á–µ—Ä–µ–∑ ccxt) –¥–ª—è –Ω—É–∂–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø–æ–∑–∏—Ü–∏–∏ (LONG=1 / SHORT=2)
# –ú—ã —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–ª–µ—á–æ –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –æ—à–∏–±–æ–∫ createOrder
# -------------------------
async def set_leverage_ccxt(position_type: int):
    params = {"openType": 1, "positionType": position_type}  # isolated
    try:
        res = await exchange.set_leverage(LEVERAGE, SYMBOL_CCXT, params=params)
        logger.info(f"set_leverage result: {res}")
    except Exception as e:
        # –Ω–µ —Ñ–∞—Ç–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ ‚Äî –ª–æ–≥–∏—Ä—É–µ–º
        logger.warning(f"set_leverage warning: {e}")

# -------------------------
# –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ —Ç–µ–ª–∞ –æ—Ä–¥–µ—Ä–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ MEXC Contract API
# side: 1=open long, 2=open short, 3=close long, 4=close short
# type: 5 = MARKET
# openType: 1 = isolated
# positionMode: 2 = hedge (–≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏)
# -------------------------
def build_order_body(side: int, vol, external_oid: str, tp_price: Optional[float] = None, is_close=False) -> dict:
    order = {
        "symbol": MEXC_SYMBOL,      # "XRP_USDT"
        "vol": vol,
        "side": side,
        "type": 5,                  # market
        "openType": 1,              # isolated
        "leverage": LEVERAGE,
        "externalOid": external_oid,
        "positionMode": 2           # hedge mode
    }
    if is_close:
        order["reduceOnly"] = True
    if tp_price is not None:
        # takeProfitPrice ‚Äî —Ü–µ–Ω–∞ —Ç–µ–π–∫-–ø—Ä–æ—Ñ–∏—Ç–∞
        order["takeProfitPrice"] = round(tp_price, 8)
    return order

# -------------------------
# –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º event loop)
# –∏—Å–ø–æ–ª—å–∑—É–µ–º run_in_executor, —á—Ç–æ–±—ã –≤—ã–∑–≤–∞—Ç—å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π Bot.send_message
# -------------------------
async def tg_send(text: str):
    try:
        loop = asyncio.get_event_loop()
        await loop.run_in_executor(None, bot.send_message, TELEGRAM_CHAT_ID, text)
    except Exception as e:
        logger.warning(f"tg_send error: {e}")

# -------------------------
# –§—É–Ω–∫—Ü–∏—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ (–≥–ª–∞–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞)
# - –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ñ–ª–∞–≥ active_position (–Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–µ–º –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –ø–æ–∑–∏—Ü–∏—è)
# - —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –æ–±—ä–µ–º, —Ñ–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–ª–æ –æ—Ä–¥–µ—Ä–∞, —Å—Ç–∞–≤–∏—Ç –ø–ª–µ—á–æ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –Ω–∞ MEXC
# - TP —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö –æ—Ç –≤—Ö–æ–¥–∞ –∏ –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ body -> takeProfitPrice
# -------------------------
async def open_position(signal: str, tp_percent: Optional[float] = None):
    global active_position, last_trade
    async with position_lock:
        # –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        if active_position:
            logger.info("–ê–∫—Ç–∏–≤–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–∏–≥–Ω–∞–ª")
            await tg_send("–î–£–ü–õ–ò–ö–ê–¢ –°–ò–ì–ù–ê–õ–ê: –ø–æ–∑–∏—Ü–∏—è —É–∂–µ –∞–∫—Ç–∏–≤–Ω–∞ ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—é")
            return {"status": "skipped", "reason": "active_position"}

        try:
            # 1) –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É
            price = await fetch_price()
            if price <= 0:
                raise Exception("–ù–µ–≤–∞–ª–∏–¥–Ω–∞—è —Ü–µ–Ω–∞")

            # 2) —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ–±—ä–µ–º vol (–∫–æ–Ω—Ç—Ä–∞–∫—Ç—ã)
            vol = await calculate_vol(FIXED_AMOUNT_USDT, price)

            # 3) –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å side –∏ position_type –¥–ª—è –ø–ª–µ—á–∞
            side = 1 if signal.lower() == "buy" else 2
            position_type = 1 if side == 1 else 2

            # 4) —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–ª–µ—á–æ (–¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
            await set_leverage_ccxt(position_type)

            # 5) —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å TP —Ü–µ–Ω—É, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω tp_percent
            tp_price = None
            if tp_percent is not None:
                if side == 1:
                    tp_price = price * (1 + tp_percent / 100.0)
                else:
                    tp_price = price * (1 - tp_percent / 100.0)

            # 6) –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å —Ç–µ–ª–æ –æ—Ä–¥–µ—Ä–∞
            external_oid = f"bot_{int(time.time()*1000)}"
            order_body = build_order_body(side=side, vol=vol, external_oid=external_oid, tp_price=tp_price)

            # 7) —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ä–¥–µ—Ä–∞ –Ω–∞ –±–∏—Ä–∂—É
            await tg_send(f"üì° –û—Ç–ø—Ä–∞–≤–ª—è—é –æ—Ä–¥–µ—Ä: {signal.upper()} vol={vol} @ price={price:.6f} TP={'{:.6f}'.format(tp_price) if tp_price else '‚Äî'}")
            resp = await mexc_post("/api/v1/private/order/submit", order_body)

            # 8) –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–∞
            success = resp.get("success") or str(resp.get("success")).lower() in ("true", "1")
            if not success:
                code = resp.get("code", "unknown")
                msg = resp.get("message") or resp.get("msg") or str(resp.get("data"))
                await tg_send(f"‚ùå –û—à–∏–±–∫–∞ MEXC: code={code}, msg={msg}")
                logger.error(f"Order failed: {resp}")
                return {"status": "error", "resp": resp}

            # 9) –∏–∑–≤–ª–µ—á—å order_id –∏–∑ data (—Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è)
            data_field = resp.get("data")
            order_id = None
            if isinstance(data_field, dict):
                order_id = data_field.get("orderId") or data_field.get("id") or data_field
            else:
                order_id = data_field

            # 10) –ø–æ–º–µ—Ç–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é –∞–∫—Ç–∏–≤–Ω–æ–π –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å info
            active_position = True
            last_trade = {
                "signal": signal,
                "side": "LONG" if side == 1 else "SHORT",
                "vol": vol,
                "entry_price": price,
                "tp_price": tp_price,
                "order_id": order_id,
                "timestamp": time.time()
            }

            await tg_send(f"‚úÖ –û–¢–ö–†–´–¢–ê –ü–û–ó–ò–¶–ò–Ø: {last_trade['side']}\nSymbol: {MEXC_SYMBOL}\nQty(vol): {vol}\nEntry: ${price:.6f}\nTP: {tp_price if tp_price else '‚Äî'}\nOrderID: {order_id}")
            logger.info(f"–û—Ç–∫—Ä—ã—Ç–∞ –ø–æ–∑–∏—Ü–∏—è: {last_trade}")
            return {"status": "ok", "order_id": order_id, "last_trade": last_trade}

        except Exception as e:
            logger.error(f"open_position error: {e}\n{traceback.format_exc()}")
            await tg_send(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏: {e}")
            return {"status": "error", "error": str(e)}

# -------------------------
# –†–µ–∞–ª–∏–∑—É–µ–º –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (force close) ‚Äî reduceOnly market order
# -------------------------
async def close_position():
    global active_position, last_trade
    async with position_lock:
        if not active_position:
            return {"status": "no_position"}
        try:
            # –ø–æ–ª—É—á–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ —á–µ—Ä–µ–∑ ccxt
            positions = await exchange.fetch_positions([SYMBOL_CCXT])
            pos = next((p for p in positions if p.get("symbol") == SYMBOL_CCXT and float(p.get("contracts", 0)) > 0), None)
            if not pos:
                active_position = False
                last_trade = None
                await tg_send("‚ö†Ô∏è –ü–æ–∑–∏—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è")
                return {"status": "no_position_found"}

            side_str = pos.get("side")
            qty = float(pos.get("contracts", 0))
            # –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è: 3 = close long, 4 = close short
            close_side = 3 if side_str == "long" else 4

            external_oid = f"bot_close_{int(time.time()*1000)}"
            order_body = build_order_body(side=close_side, vol=qty, external_oid=external_oid, is_close=True)
            resp = await mexc_post("/api/v1/private/order/submit", order_body)

            success = resp.get("success") or str(resp.get("success")).lower() in ("true", "1")
            if not success:
                await tg_send(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è: {resp}")
                return {"status": "error", "resp": resp}

            active_position = False
            last_trade = None
            await tg_send(f"‚úÖ –ü–æ–∑–∏—Ü–∏—è –∑–∞–∫—Ä—ã—Ç–∞ (qty={qty})")
            return {"status": "ok", "resp": resp}
        except Exception as e:
            logger.error(f"close_position error: {e}\n{traceback.format_exc()}")
            await tg_send(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–∏: {e}")
            return {"status": "error", "error": str(e)}

# -------------------------
# FastAPI webhook endpoint
# –û–∂–∏–¥–∞–µ—Ç JSON: {"signal":"buy"|"sell"|"close", "tp": 0.5}
# –¢—Ä–µ–±—É–µ—Ç header Authorization: Bearer <WEBHOOK_SECRET>
# -------------------------
@app.post("/webhook")
async def webhook(request: Request):
    try:
        auth = request.headers.get("Authorization", "")
        if WEBHOOK_SECRET and auth != f"Bearer {WEBHOOK_SECRET}":
            logger.warning("Unauthorized webhook call")
            raise HTTPException(status_code=401, detail="Unauthorized")

        payload = await request.json()
        signal = (payload.get("signal") or "").lower()
        tp = payload.get("tp")  # –ø—Ä–æ—Ü–µ–Ω—Ç TP, –Ω–∞–ø—Ä–∏–º–µ—Ä 0.5

        if signal not in ("buy", "sell", "close"):
            raise HTTPException(status_code=400, detail="signal must be buy/sell/close")

        if signal == "close":
            # –∑–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –≤ —Ñ–æ–Ω–µ
            asyncio.create_task(close_position())
            return JSONResponse({"status": "closing"})

        # –ø–∞—Ä—Å–∏–º tp (–µ—Å–ª–∏ –∑–∞–¥–∞–Ω)
        try:
            tp_val = float(tp) if tp is not None else None
        except Exception:
            tp_val = None

        # –∑–∞–ø—É—Å–∫–∞–µ–º –æ—Ç–∫—Ä—ã—Ç–∏–µ –≤ —Ñ–æ–Ω–µ, —á—Ç–æ–±—ã –±—ã—Å—Ç—Ä–æ –æ—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ webhook
        asyncio.create_task(open_position(signal, tp_val))
        return JSONResponse({"status": "accepted", "signal": signal, "tp": tp_val})
    except HTTPException as he:
        raise he
    except Exception as e:
        logger.error(f"Webhook handling error: {e}\n{traceback.format_exc()}")
        raise HTTPException(status_code=500, detail=str(e))

# -------------------------
# –ü—Ä–æ—Å—Ç–∞—è health-—Å—Ç—Ä–∞–Ω–∏—Ü–∞
# -------------------------
@app.get("/health")
async def health():
    return {"status": "ok", "active_position": active_position, "last_trade": last_trade}

# -------------------------
# On startup: –∑–∞–≥—Ä—É–∑–∏–º —Ä—ã–Ω–∫–∏ –∏ –ø—Ä–∏—à–ª—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram
# -------------------------
@app.on_event("startup")
async def on_startup():
    try:
        await exchange.load_markets(reload=True)
    except Exception as e:
        logger.warning(f"load_markets warning: {e}")
    try:
        await tg_send(f"–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. SYMBOL={MEXC_SYMBOL}, AMOUNT={FIXED_AMOUNT_USDT} USDT, LEVERAGE={LEVERAGE}x")
    except Exception:
        pass

# -------------------------
# On shutdown: –∞–∫–∫—É—Ä–∞—Ç–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
# -------------------------
@app.on_event("shutdown")
async def on_shutdown():
    try:
        await exchange.close()
    except Exception:
        pass
    try:
        await tg_send("–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception:
        pass

# -------------------------
# –ó–∞–ø—É—Å–∫ –ª–æ–∫–∞–ª—å–Ω–æ
# -------------------------
if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", "8000"))
    uvicorn.run("main:app", host="0.0.0.0", port=port, log_level="info")
